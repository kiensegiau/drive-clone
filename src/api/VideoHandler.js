const path = require("path");
const fs = require("fs");
const { exec } = require("child_process");
const axios = require("axios");
const { google } = require("googleapis");
const { credentials, SCOPES } = require("../config/auth.js"); // Import auth config
const ChromeManager = require("./ChromeManager");
const ProcessLogger = require("../utils/ProcessLogger");
const { getLongPath } = require("../utils/pathUtils");
const https = require("https");

class VideoHandler {
  constructor(oAuth2Client = null) {
    try {
      this.MAX_RETRIES = 5;
      this.RETRY_DELAY = 2000;
      this.activeDownloads = 0;
      this.MAX_CONCURRENT_DOWNLOADS = 32;
      this.downloadQueue = [];
      this.videoQueue = [];
      this.processingVideo = false;
      this.TEMP_DIR = getLongPath(path.join(__dirname, "temp"));
      this.cookies = null;
      this.chromeManager = ChromeManager.getInstance();
      this.processLogger = new ProcessLogger();
      
      // S·ª≠ d·ª•ng oAuth2Client ƒë∆∞·ª£c truy·ªÅn v√†o
      this.oAuth2Client = oAuth2Client;
      
      if (this.oAuth2Client) {
        this.drive = google.drive({
          version: "v3",
          auth: this.oAuth2Client,
        });
      }

      // T·∫°o th∆∞ m·ª•c temp n·∫øu ch∆∞a t·ªìn t·∫°i
      if (!fs.existsSync(this.TEMP_DIR)) {
        try {
          fs.mkdirSync(this.TEMP_DIR, { recursive: true });
        } catch (error) {
          console.error("‚ùå L·ªói t·∫°o th∆∞ m·ª•c temp:", error.message);
        }
      }

      // Th√™m cache cho session
      this.sessionCache = {
        cookies: null,
        xsrfToken: null,
        sessionId: null,
        lastUpdate: null,
        expiryTime: 30 * 60 * 1000 // 30 ph√∫t
      };
    } catch (error) {
      console.error("‚ùå L·ªói kh·ªüi t·∫°o VideoHandler:", error.message);
      throw error;
    }
  }

  async getAccessToken() {
    const authUrl = this.oAuth2Client.generateAuthUrl({
      access_type: "offline",
      scope: SCOPES,
    });

    console.log("üîë Truy c·∫≠p URL n√†y ƒë·ªÉ x√°c th·ª±c:");
    console.log(authUrl);
    console.log(
      "\nSau khi x√°c th·ª±c, copy code v√† l∆∞u v√†o file token.json v·ªõi ƒë·ªãnh d·∫°ng:"
    );
    console.log(`{
      "access_token": "your_access_token",
      "refresh_token": "your_refresh_token",
      "scope": "${SCOPES.join(" ")}",
      "token_type": "Bearer",
      "expiry_date": 1234567890000
    }`);

    throw new Error("C·∫ßn x√°c th·ª±c Google Drive tr∆∞·ªõc khi upload");
  }

  async processVideo(
    fileId,
    fileName,
    targetFolderId,
    depth = 0,
    profileId = null
  ) {
    const indent = "  ".repeat(depth);
    const startTime = Date.now();
    let tempFiles = [];

    try {
      console.log(`${indent}=== X·ª≠ l√Ω video: ${fileName} ===`);

      // T·∫°o t√™n file an to√†n
      const safeFileName = fileName.replace(/[/\\?%*:|"<>]/g, "-");
      const outputPath = path.join(this.TEMP_DIR, safeFileName);
      tempFiles.push(outputPath);

      // Log b·∫Øt ƒë·∫ßu x·ª≠ l√Ω
      this.processLogger.logProcess({
        type: "video_process",
        status: "start",
        fileName,
        fileId,
        targetFolderId,
        timestamp: new Date().toISOString(),
      });

      // T√¨m URL video
      const videoUrl = await this.findVideoUrl(
        fileId,
        fileName,
        depth,
        profileId
      );

      if (!videoUrl) {
        throw new Error("Kh√¥ng t√¨m th·∫•y URL video");
      }

      // T·∫£i video v·ªÅ temp
      console.log(`${indent}üì• B·∫Øt ƒë·∫ßu t·∫£i video...`);
      await this.downloadVideoWithChunks(
        videoUrl,
        outputPath,
        depth,
        fileId,
        fileName,
        profileId
      );

      // Log ho√†n th√†nh t·∫£i
      const stats = fs.statSync(outputPath);
      try {
        this.processLogger.logProcess({
          type: "video_process",
          status: "downloaded",
          fileName,
          fileId,
          fileSize: stats.size,
          duration: Date.now() - startTime,
          timestamp: new Date().toISOString(),
        });
      } catch (logError) {
        console.error(`${indent}‚ö†Ô∏è L·ªói ghi log download:`, logError.message);
      }

      // Upload video v·ªõi try-catch
      try {
        console.log(`${indent}üì§ ƒêang upload video l√™n Drive...`);
        const uploadedFile = await this.uploadFile(
          outputPath,
          fileName,
          targetFolderId,
          "video/mp4"
        );

        // Log ho√†n th√†nh upload
        try {
          this.processLogger.logProcess({
            type: "video_process",
            status: "uploaded",
            fileName,
            fileId,
            targetFileId: uploadedFile.id,
            fileSize: stats.size,
            duration: Date.now() - startTime,
            driveViewUrl: `https://drive.google.com/file/d/${uploadedFile.id}/view`,
            driveDownloadUrl: `https://drive.google.com/uc?export=download&id=${uploadedFile.id}`,
            timestamp: new Date().toISOString(),
          });
        } catch (logError) {
          console.error(`${indent}‚ö†Ô∏è L·ªói ghi log upload:`, logError.message);
        }

        return { success: true, fileId: uploadedFile.id };
      } catch (uploadError) {
        throw new Error(`L·ªói upload: ${uploadError.message}`);
      }
    } catch (error) {
      // Log l·ªói t·ªïng th·ªÉ
      try {
        this.processLogger.logProcess({
          type: "video_process",
          status: "error",
          fileName,
          fileId,
          error: error.message,
          duration: Date.now() - startTime,
          timestamp: new Date().toISOString(),
        });
      } catch (logError) {
        console.error(`${indent}‚ö†Ô∏è L·ªói ghi log l·ªói:`, logError.message);
      }
      console.error(`${indent}‚ùå L·ªói x·ª≠ l√Ω video ${fileName}:`, error.message);
      return { success: false, error: error.message };
    } finally {
      // Cleanup temp files
      for (const file of tempFiles) {
        try {
          if (fs.existsSync(file)) {
            fs.unlinkSync(file);
          }
        } catch (error) {
          console.warn(`${indent}‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a file t·∫°m: ${file}`);
        }
      }
    }
  }

  // Th√™m helper method ƒë·ªÉ parse itag t·ª´ URL
  getItagFromUrl(url) {
    const itagMatch = url.match(/itag=(\d+)/);
    return itagMatch ? parseInt(itagMatch[1]) : 0;
  }

  async startDownload(videoUrl, file, targetFolderId, depth) {
    const indent = "  ".repeat(depth);
    const safeFileName = file.name.replace(/[/\\?%*:|"<>]/g, "-");
    const outputPath = path.join(this.TEMP_DIR, safeFileName);

    try {
      console.log(`${indent}üì• B·∫Øt ƒë·∫ßu t·∫£i: ${file.name}`);

      // T·∫£i video v·ªõi chunks
      await this.downloadVideoWithChunks(videoUrl, outputPath);

      // Upload file sau khi t·∫£i xong
      console.log(`${indent}üì§ ƒêang upload: ${file.name}`);
      await this.uploadFile(outputPath, file.name, targetFolderId, "video/mp4");

      // X√≥a file t·∫°m sau khi upload xong
      if (fs.existsSync(outputPath)) {
        fs.unlinkSync(outputPath);
        console.log(`${indent}üóëÔ∏è ƒê√£ x√≥a file t·∫°m`);
      }

      console.log(`${indent}‚úÖ Ho√†n th√†nh: ${file.name}`);
      return true;
    } catch (error) {
      console.error(`${indent}‚ùå L·ªói t·∫£i/upload ${file.name}:`, error.message);
      // D·ªçn d·∫πp file t·∫°m n·∫øu c√≥ l·ªói
      if (fs.existsSync(outputPath)) {
        fs.unlinkSync(outputPath);
      }
      return false;
    }
  }

  async killChrome() {
    try {
      if (process.platform === "win32") {
        try {
          await new Promise((resolve) => {
            exec("taskkill /F /IM chrome.exe /T", (error) => {
              if (error) {
                console.log("‚ö†Ô∏è Kh√¥ng c√≥ Chrome process n√†o ƒëang ch·∫°y");
              } else {
                console.log("‚úÖ ƒê√£ kill Chrome process");
              }
              resolve();
            });
          });
        } catch (execError) {
          console.error("‚ùå L·ªói th·ª±c thi l·ªánh kill Chrome:", execError.message);
        }

        try {
          await new Promise((resolve) => setTimeout(resolve, 1000));
        } catch (timeoutError) {
          console.error(
            "‚ùå L·ªói timeout sau kill Chrome:",
            timeoutError.message
          );
        }
      }
    } catch (error) {
      console.error("‚ùå L·ªói killChrome:", error.message);
    }
  }

  getVideoQuality(itag) {
    const itagQualities = {
      37: 1080, // MP4 1080p
      137: 1080, // MP4 1080p
      22: 720, // MP4 720p
      136: 720, // MP4 720p
      135: 480, // MP4 480p
      134: 360, // MP4 360p
      133: 240, // MP4 240p
      160: 144, // MP4 144p
      // Th√™m c√°c itag kh√°c n·∫øu c·∫ßn
      38: 3072, // MP4 4K
      266: 2160, // MP4 2160p
      264: 1440, // MP4 1440p
      299: 1080, // MP4 1080p 60fps
      298: 720, // MP4 720p 60fps
    };
    return itagQualities[itag] || 0;
  }

  // Th√™m method ki·ªÉm tra v√† l·∫•y session
  async getValidSession(fileId, profileId = null) {
    // Ki·ªÉm tra cache c√≤n h·∫°n kh√¥ng
    const now = Date.now();
    if (
      this.sessionCache.cookies && 
      this.sessionCache.lastUpdate && 
      (now - this.sessionCache.lastUpdate < this.sessionCache.expiryTime)
    ) {
      console.log('üìù S·ª≠ d·ª•ng session t·ª´ cache');
      return {
        cookies: this.sessionCache.cookies,
        xsrfToken: this.sessionCache.xsrfToken,
        sessionId: this.sessionCache.sessionId
      };
    }

    // N·∫øu h·∫øt h·∫°n ho·∫∑c ch∆∞a c√≥, t·∫°o session m·ªõi
    console.log('üîÑ T·∫°o session m·ªõi...');
    let browser;
    try {
      browser = await this.chromeManager.getBrowser(profileId);
      const page = await browser.newPage();

      await page.goto(`https://drive.google.com/file/d/${fileId}/view`, {
        waitUntil: "networkidle0",
        timeout: 30000,
      });

      const cookies = await page.cookies();
      const localStorage = await page.evaluate(() =>
        Object.entries(window.localStorage)
      );

      let xsrfToken = "";
      let sessionId = "";
      for (const [key, value] of localStorage) {
        if (key.includes("token")) xsrfToken = value;
        if (key.includes("session")) sessionId = value;
      }

      // C·∫≠p nh·∫≠t cache
      this.sessionCache = {
        cookies,
        xsrfToken,
        sessionId,
        lastUpdate: now,
        expiryTime: 30 * 60 * 1000
      };

      return { cookies, xsrfToken, sessionId };
    } finally {
      if (browser) await browser.close();
    }
  }

  // S·ª≠a l·∫°i method downloadVideoWithChunks ƒë·ªÉ s·ª≠ d·ª•ng session cache
  async downloadVideoWithChunks(url, outputPath, depth = 0, fileId, fileName, profileId = null) {
    const indent = "  ".repeat(depth);
    const MAX_RETRIES = 5;
    
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        console.log(`${indent}üì• B·∫Øt ƒë·∫ßu t·∫£i video...`);

        // S·ª≠ d·ª•ng session t·ª´ cache ƒë√£ l∆∞u trong findVideoUrl
        if (!this.sessionCache.cookies) {
          throw new Error("Kh√¥ng t√¨m th·∫•y session, c·∫ßn ch·∫°y findVideoUrl tr∆∞·ªõc");
        }

        const headers = {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0",
          Accept: "*/*",
          "Accept-Encoding": "gzip, deflate, br",
          Connection: "keep-alive",
          Cookie: this.sessionCache.cookies.map((c) => `${c.name}=${c.value}`).join("; "),
          Referer: `https://drive.google.com/file/d/${fileId}/view`,
          Origin: "https://drive.google.com",
          "Sec-Fetch-Dest": "video",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Site": "same-site"
        };

        if (this.sessionCache.xsrfToken) {
          headers["Authorization"] = `Bearer ${this.sessionCache.xsrfToken}`;
        }

        if (this.sessionCache.sessionId) {
          headers["X-Session-Id"] = this.sessionCache.sessionId;
        }

        // Ki·ªÉm tra URL
        const headResponse = await axios.head(url, { headers });
        console.log(`${indent}‚úÖ Ki·ªÉm tra URL th√†nh c√¥ng:`, {
          status: headResponse.status,
          contentType: headResponse.headers["content-type"],
          contentLength: headResponse.headers["content-length"],
        });

        // T·∫£i video v·ªõi m·ªôt request duy nh·∫•t
        const response = await axios({
          method: "get",
          url: url,
          headers: headers,
          responseType: "stream",
          maxRedirects: 5,
          timeout: 60000,
        });

        // X·ª≠ l√Ω download stream
        const totalSize = parseInt(response.headers["content-length"], 10);
        const writer = fs.createWriteStream(outputPath);
        let downloadedSize = 0;
        let lastLogTime = Date.now();
        let lastDownloadedSize = 0;

        await new Promise((resolve, reject) => {
          response.data.pipe(writer);

          response.data.on("data", (chunk) => {
            downloadedSize += chunk.length;
            const now = Date.now();
            if (now - lastLogTime > 1000) {
              const progress = ((downloadedSize / totalSize) * 100).toFixed(2);
              const speed = ((downloadedSize - lastDownloadedSize) / 1024 / 1024).toFixed(2);
              console.log(`${indent}‚è≥ ƒê√£ t·∫£i: ${progress}% (${speed} MB/s)`);
              lastLogTime = now;
              lastDownloadedSize = downloadedSize;
            }
          });

          writer.on("finish", resolve);
          writer.on("error", reject);
          response.data.on("error", reject);
        });

        console.log(`${indent}‚úÖ T·∫£i th√†nh c√¥ng!`);
        return;

      } catch (error) {
        console.error(`${indent}‚ùå L·ªói t·∫£i video (l·∫ßn ${attempt}/${MAX_RETRIES}):`, {
          message: error.message,
          status: error.response?.status,
        });

        if (fs.existsSync(outputPath)) {
          fs.unlinkSync(outputPath);
        }

        if (attempt < MAX_RETRIES) {
          console.log(`${indent}‚è≥ ƒê·ª£i 2s tr∆∞·ªõc khi th·ª≠ l·∫°i...`);
          await new Promise(r => setTimeout(r, 2000));
          continue;
        }
        throw error;
      }
    }
  }

  // C·∫≠p nh·∫≠t ph∆∞∆°ng th·ª©c refresh cookies
  async refreshCookies(profileId = null) {
    let browser;
    try {
      console.log(`üåê Kh·ªüi ƒë·ªông Chrome v·ªõi profile: ${profileId || "default"}`);
      browser = await this.chromeManager.getBrowser(profileId);
      const page = await browser.newPage();

      console.log(`üìù Truy c·∫≠p Drive ƒë·ªÉ l·∫•y cookies m·ªõi...`);
      await page.goto("https://drive.google.com", {
        waitUntil: "networkidle0",
        timeout: 30000,
      });

      this.cookies = await page.cookies();
      console.log(`‚úÖ ƒê√£ l·∫•y ${this.cookies.length} cookies m·ªõi`);
      return true;
    } catch (error) {
      console.error("‚ùå L·ªói refresh cookies:", error.message);
      return false;
    } finally {
      if (browser) {
        await browser.close();
      }
    }
  }

  // Th√™m ph∆∞∆°ng th·ª©c refresh URL video
  async refreshVideoUrl(fileId, fileName, depth) {
    try {
      return await this.findVideoUrl(fileId, fileName, depth);
    } catch (error) {
      console.error("‚ùå L·ªói refresh URL video:", error.message);
      return null;
    }
  }

  async uploadFile(filePath, fileName, targetFolderId, mimeType) {
    const MAX_RETRIES = 5;
    const RETRY_DELAY = 5000;

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      try {
        const fileSize = fs.statSync(filePath).size;
        const fileSizeMB = (fileSize / (1024 * 1024)).toFixed(2);

        console.log(`üì§ ƒêang upload ${fileName}...`);
        console.log(`üì¶ K√≠ch th∆∞·ªõc file: ${fileSizeMB}MB`);

        // Thi·∫øt l·∫≠p metadata gi·ªëng h·ªát tr√¨nh duy·ªát web
        const fileMetadata = {
          name: fileName,
          parents: [targetFolderId],
          description: "",
          // Th√™m c√°c thu·ªôc t√≠nh ƒë·ªÉ x·ª≠ l√Ω video gi·ªëng web UI
          properties: {
            source: "web_client",
            upload_source: "web_client",
            upload_time: Date.now().toString(),
            upload_agent: "Mozilla/5.0 Chrome/120.0.0.0",
            processed: "false",
            processing_status: "PENDING",
          },
          appProperties: {
            force_high_quality: "true",
            processing_priority: "HIGH",
          },
        };

        // T·∫°o readable stream v·ªõi chunk size gi·ªëng web
        const media = {
          mimeType: mimeType,
          body: fs.createReadStream(filePath, {
            highWaterMark: 256 * 1024, // 256KB chunks nh∆∞ web
          }),
        };

        // Upload v·ªõi c·∫•u h√¨nh gi·ªëng web UI
        const response = await this.drive.files.create({
          requestBody: fileMetadata,
          media: media,
          fields: "id, name, size, mimeType, webViewLink, webContentLink",
          supportsAllDrives: true,
          enforceSingleParent: true,
          ignoreDefaultVisibility: true,
          keepRevisionForever: true,
          uploadType: fileSize > 5 * 1024 * 1024 ? "resumable" : "multipart",
        });

        console.log(`‚ú® Upload th√†nh c√¥ng: ${fileName}`);
        console.log(`üìé File ID: ${response.data.id}`);

        // Th√™m try-catch cho ph·∫ßn set permissions
        try {
          await this.drive.permissions.create({
            fileId: response.data.id,
            requestBody: {
              role: "reader",
              type: "anyone",
              allowFileDiscovery: false,
              viewersCanCopyContent: true,
            },
            supportsAllDrives: true,
            sendNotificationEmail: false,
          });
        } catch (permError) {
          console.error(`‚ö†Ô∏è L·ªói set permissions:`, permError.message);
        }

        // Th√™m try-catch cho video processing
        try {
          await this.ensureVideoProcessing(response.data.id, "1080p");
        } catch (procError) {
          console.error(`‚ö†Ô∏è L·ªói x·ª≠ l√Ω video:`, procError.message);
        }

        return response.data;
      } catch (error) {
        console.error(
          `‚ùå L·ªói upload (l·∫ßn ${attempt + 1}/${MAX_RETRIES}):`,
          error.message
        );

        if (attempt === MAX_RETRIES - 1) {
          throw error;
        }

        console.log(` Th·ª≠ l·∫°i sau 5s...`);
        await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY));
      }
    }
  }

  // Th√™m h√†m ƒë·ªÉ theo d√µi ti·∫øn ƒë·ªô x·ª≠ l√Ω video
  async checkVideoProcessing(fileId, maxAttempts = 10) {
    console.log(`‚è≥ ƒêang ƒë·ª£i video ƒë∆∞·ª£c x·ª≠ l√Ω...`);

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const file = await this.drive.files.get({
          fileId: fileId,
          fields: "videoMediaMetadata,processingMetadata",
          supportsAllDrives: true,
        });

        try {
          if (file.data.videoMediaMetadata?.height >= 720) {
            console.log(
              `‚úÖ Video ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü ${file.data.videoMediaMetadata.height}p`
            );
            return true;
          }
        } catch (parseError) {
          console.error(`‚ö†Ô∏è L·ªói ƒë·ªçc metadata:`, parseError.message);
        }

        console.log(
          `üîÑ L·∫ßn ki·ªÉm tra ${
            attempt + 1
          }/${maxAttempts}: Video ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω...`
        );
        await new Promise((r) => setTimeout(r, 30000));
      } catch (error) {
        console.error(
          `‚ö†Ô∏è L·ªói ki·ªÉm tra x·ª≠ l√Ω video (${attempt + 1}/${maxAttempts}):`,
          error.message
        );
        if (attempt === maxAttempts - 1) throw error;
        await new Promise((r) => setTimeout(r, 5000));
      }
    }
    return false;
  }

  // Th√™m h√†m ki·ªÉm tra v√† force x·ª≠ l√Ω video sau khi upload
  async ensureVideoProcessing(fileId, targetResolution) {
    try {
      const drive = google.drive({ version: "v3", auth: this.oAuth2Client });

      // Force x·ª≠ l√Ω video
      try {
        await drive.files.update({
          fileId: fileId,
          requestBody: {
            contentHints: {
              indexableText: `video/mp4 ${targetResolution} high-quality original`,
              thumbnail: {
                image: Buffer.from("").toString("base64"),
                mimeType: "image/jpeg",
              },
            },
            properties: {
              processed: "false",
              target_resolution: targetResolution,
              processing_requested: Date.now().toString(),
              force_high_quality: "true",
            },
          },
          supportsAllDrives: true,
        });
      } catch (updateError) {
        console.error(`‚ö†Ô∏è L·ªói c·∫≠p nh·∫≠t th√¥ng tin x·ª≠ l√Ω:`, updateError.message);
      }

      // Set permissions
      try {
        await drive.permissions.create({
          fileId: fileId,
          requestBody: {
            role: "reader",
            type: "anyone",
            allowFileDiscovery: false,
            viewersCanCopyContent: true,
          },
          supportsAllDrives: true,
        });
      } catch (permError) {
        console.error(`‚ö†Ô∏è L·ªói set permissions:`, permError.message);
      }

      // Set sharing config
      try {
        await drive.files.update({
          fileId: fileId,
          requestBody: {
            copyRequiresWriterPermission: false,
            viewersCanCopyContent: true,
            writersCanShare: true,
          },
          supportsAllDrives: true,
        });
      } catch (shareError) {
        console.error(`‚ö†Ô∏è L·ªói c·∫•u h√¨nh sharing:`, shareError.message);
      }
    } catch (error) {
      console.error(`‚ùå L·ªói ensure video processing:`, error.message);
      throw error;
    }
  }

  // H√†m retry v·ªõi delay
  async retryOperation(operation) {
    for (let i = 0; i < this.MAX_RETRIES; i++) {
      try {
        return await operation();
      } catch (error) {
        if (i === this.MAX_RETRIES - 1) throw error;
        console.log(
          `‚ö†Ô∏è L·∫ßn th·ª≠ ${i + 1}/${this.MAX_RETRIES} th·∫•t b·∫°i: ${error.message}`
        );
        console.log(`‚è≥ Ch·ªù ${this.RETRY_DELAY / 1000}s tr∆∞·ªõc khi th·ª≠ l·∫°i...`);
        await new Promise((resolve) => setTimeout(resolve, this.RETRY_DELAY));
      }
    }
  }

  async downloadToLocal(
    fileId,
    fileName,
    targetDir,
    depth = 0,
    profileId = null
  ) {
    const indent = "  ".repeat(depth);
    let browser;

    try {
      console.log(`${indent}üé• T·∫£i video: ${fileName}`);

      // T·∫°o th∆∞ m·ª•c ƒë√≠ch n·∫øu ch∆∞a t·ªìn t·∫°i
      if (!fs.existsSync(targetDir)) {
        fs.mkdirSync(targetDir, { recursive: true });
      }

      const safeFileName = fileName.replace(/[/\\?%*:|"<>]/g, "-");
      const outputPath = getLongPath(path.join(targetDir, safeFileName));

      // Ki·ªÉm tra n·∫øu file ƒë√£ t·ªìn t·∫°i
      if (fs.existsSync(outputPath)) {
        console.log(`${indent}‚è© File ƒë√£ t·ªìn t·∫°i, b·ªè qua: ${safeFileName}`);
        return { success: true, filePath: outputPath };
      }

      // T√¨m URL video v·ªõi ph∆∞∆°ng th·ª©c findVideoUrl
      const videoUrl = await this.findVideoUrl(
        fileId,
        fileName,
        depth,
        profileId
      );

      if (!videoUrl) {
        throw new Error("Kh√¥ng t√¨m th·∫•y URL video");
      }

      // T·∫£i video v·ªÅ
      console.log(`${indent}üì• B·∫Øt ƒë·∫ßu t·∫£i: ${safeFileName}`);
      await this.downloadVideoWithChunks(
        videoUrl,
        outputPath,
        depth,
        fileId,
        fileName,
        profileId
      );

      console.log(`${indent}‚úÖ ƒê√£ t·∫£i xong: ${safeFileName}`);
      return { success: true, filePath: outputPath };
    } catch (error) {
      console.error(`${indent}‚ùå L·ªói t·∫£i video:`, error.message);
      return { success: false, error: error.message };
    }
  }

  async findVideoUrl(fileId, fileName, depth = 0, profileId = null) {
    const indent = "  ".repeat(depth);
    let browser;
    let foundVideoUrls = [];

    try {
      await this.killChrome();
      await new Promise((r) => setTimeout(r, 1000));

      console.log(`${indent}üöÄ Kh·ªüi ƒë·ªông Chrome...`);
      browser = await this.chromeManager.getBrowser(profileId);
      const page = await browser.pages();
      const activePage = page[0] || await browser.newPage();

      console.log(`${indent}üåê ƒêang m·ªü trang video...`);
      await activePage.goto(`https://drive.google.com/file/d/${fileId}/view`, {
        waitUntil: "networkidle0",
        timeout: 30000,
      });

      // L∆∞u session v√†o cache
      const cookies = await activePage.cookies();
      const localStorage = await activePage.evaluate(() =>
        Object.entries(window.localStorage)
      );

      let xsrfToken = "";
      let sessionId = "";
      for (const [key, value] of localStorage) {
        if (key.includes("token")) xsrfToken = value;
        if (key.includes("session")) sessionId = value;
      }

      this.sessionCache = {
        cookies,
        xsrfToken,
        sessionId,
        lastUpdate: Date.now(),
        expiryTime: 30 * 60 * 1000
      };

      // Theo d√µi network requests ƒë·ªÉ t√¨m video info
      await activePage.setRequestInterception(true);
      
      activePage.on('request', request => {
        if (request.url().includes('get_video_info')) {
          console.log(`${indent}üîç Ph√°t hi·ªán request video:`, request.url());
        }
        request.continue();
      });

      // L·∫•y response ch·ª©a th√¥ng tin video
      const videoInfoResponse = await activePage.waitForResponse(
        response => response.url().includes('get_video_info'),
        { timeout: 30000 }
      );

      const responseText = await videoInfoResponse.text();
      const videoInfo = new URLSearchParams(responseText);

      // T√¨m URL t·ª´ fmt_stream_map
      if (videoInfo.has('fmt_stream_map')) {
        console.log(`${indent}üé• T√¨m th·∫•y fmt_stream_map`);
        const fmtStreamMap = videoInfo.get('fmt_stream_map');
        const streams = fmtStreamMap.split(',');

        for (const stream of streams) {
          const [itag, url] = stream.split('|');
          const quality = this.getVideoQuality(parseInt(itag));
          if (quality) {
            console.log(`${indent}üìù Stream: itag=${itag} (${quality}p)`);
            foundVideoUrls.push({ url, quality, source: 'fmt_stream_map' });
          }
        }
      }

      // T√¨m URL t·ª´ player_response
      if (videoInfo.has('player_response')) {
        console.log(`${indent}‚ú® T√¨m th·∫•y formats trong player_response`);
        const playerResponse = JSON.parse(videoInfo.get('player_response'));
        
        if (playerResponse.streamingData) {
          const { formats, adaptiveFormats } = playerResponse.streamingData;

          // X·ª≠ l√Ω formats th∆∞·ªùng
          if (formats) {
            for (const format of formats) {
              const quality = this.getVideoQuality(format.itag);
              if (quality) {
                console.log(`${indent}üìù Format: itag=${format.itag}, ${quality}p`);
                foundVideoUrls.push({ url: format.url, quality, source: 'formats' });
              }
            }
          }

          // X·ª≠ l√Ω adaptive formats
          if (adaptiveFormats) {
            for (const format of adaptiveFormats) {
              if (format.mimeType?.includes('video/mp4')) {
                const quality = this.getVideoQuality(format.itag);
                if (quality) {
                  console.log(`${indent}üìù Adaptive Format: itag=${format.itag}, ${quality}p`);
                  foundVideoUrls.push({ url: format.url, quality, source: 'adaptive' });
                }
              }
            }
          }
        }
      }

      // Log t·∫•t c·∫£ URLs t√¨m ƒë∆∞·ª£c
      console.log(`${indent}üìä T·∫•t c·∫£ URL t√¨m ƒë∆∞·ª£c:`);
      foundVideoUrls.forEach(({ quality, source }) => {
        console.log(`  - ${quality}p (${source})`);
      });

      // Ch·ªçn URL ch·∫•t l∆∞·ª£ng cao nh·∫•t
      foundVideoUrls.sort((a, b) => b.quality - a.quality);
      const bestVideo = foundVideoUrls[0];
      
      if (!bestVideo) {
        throw new Error("Kh√¥ng t√¨m th·∫•y URL video n√†o");
      }

      console.log(`${indent}üéØ Ch·ªçn ch·∫•t l∆∞·ª£ng cao nh·∫•t: ${bestVideo.quality}p (${bestVideo.source})`);
      return bestVideo.url;

    } catch (error) {
      console.error(`${indent}‚ùå L·ªói t√¨m URL video:`, error.message);
      throw error;
    } finally {
      if (browser) await browser.close();
    }
  }

  // Helper method ƒë·ªÉ l·∫•y ch·∫•t l∆∞·ª£ng video t·ª´ itag
  getVideoQuality(itag) {
    const qualityMap = {
      37: 1080, // MP4 1080p
      22: 720, // MP4 720p
      59: 480, // MP4 480p
      18: 360, // MP4 360p
      // Th√™m c√°c itag kh√°c n·∫øu c·∫ßn
    };
    return qualityMap[itag] || 0;
  }
}

module.exports = VideoHandler;
